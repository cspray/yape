---
layout: article

title: Adding New Enum Dependencies
description: Sometimes your Enum may need to have multiple pieces of data associated with it. This guide details exactly how you can adjust the constructor dependencies that your Enum requires to provide additional pieces of data.
---
<p class="content">
  One of the advantages of object backed Enums is that you may have multiple pieces of data associated to them. The implementation
  of the Enum was designed in such a way to make this a straight-forward, easy-to-implement process.
</p>

<p class="content">
  Expanding on the Compass enum <a href="/tutorials/create-enum">from the Creating an Enum Tutorial</a> we will adjust the
  Compass to also provide the abbreviation for each direction. First, our original compass should look something like:
</p>

<pre class="content"><code class="language-php">&lt;?php

namespace YourNamespace\Enums;

use Cspray\Yape\Enum;
use Cspray\Yape\EnumTrait;

final class Compass implements Enum {

    use EnumTrait;

    public static function North() : self {
        return self::getSingleton('North');
    }

    public static function South() : self {
        return self::getSingleton('South');
    }

    public static function East() : self {
        return self::getSingleton('East');
    }

    public static function West() : self {
        return self::getSingleton('West');
    }

    protected static function getAllowedValues() : array {
        return ['North', 'South', 'East', 'West'];
    }

}</code></pre>

<p class="content">
  For our example we'll implement the <code>'N'</code> abbreviation and leave the remaining three as an exercise left to
  the reader.
</p>

<h4 class="is-size-5" id="step-1">Step #1 - Add the property for our piece of data</h4>
<p class="content">
  The first thing that we'll need to do is add a property that will store the new piece of data. This value
  <strong>should be private</strong> and only publicly accessible through a getter method.
</p>

<pre class="content"><code class="language-php">&lt;php

namespace YourNamespace\Enums;

use Cspray\Yape\Enum;
use Cspray\Yape\EnumTrait;

final class Compass implements Enum {

    use EnumTrait;

    private $abbreviation;

    // ... rest of the class

}</code></pre>

<h4 class="is-size-5" id="step-2">Step #2 - Override private constructor</h4>
<p class="content">
  The default constructor is provided by the <code>EnumTrait</code> and we'll want to override this to provide the
  additional abbreviation dependency. Keep in mind that the first dependency of an Enum <strong>MUST</strong> be its
  <code>toString</code> representation. This constructor <strong>SHOULD</strong> be private as we only want Enums to
  be generated through the static methods defined on the class.
</p>

<pre class="content"><code class="language-php">&lt;php

namespace YourNamespace\Enums;

use Cspray\Yape\Enum;
use Cspray\Yape\EnumTrait;

final class Compass implements Enum {

    use EnumTrait;

    private $abbreviation;

    private function __construct(string $name, string $abbreviation) {

    }

    // ... rest of the class

}</code></pre>

<h4 class="is-size-5" id="step-3">Step #3 - Set appropriate data in constructor</h4>
<p class="content">
  After we've created the constructor next we need to make sure the appropriate data is set on the enum properties. For
  the <code>$name</code> we should ensure to call `setName()` which is provided by <code>EnumTrait</code>. The <code>$abbreviation</code>
  should be set to the property we added in <a href="#step-1">step #1</a>.
</p>

<pre class="content"><code class="language-php">&lt;php

namespace YourNamespace\Enums;

use Cspray\Yape\Enum;
use Cspray\Yape\EnumTrait;

final class Compass implements Enum {

    use EnumTrait;

    private $abbreviation;

    private function __construct(string $name, string $abbreviation) {
        $this->setName($name);
        $this->abbreviation = $abbreviation;
    }

    // ... rest of the class

}</code></pre>

<div class="message is-info">
  <div class="message-body">
    It is critical that you call <code>setName</code> if you override the constructor provided by <code>EnumTrait</code>.
    If this method is not called your Enum is likely to not function correctly in all scenarios. Specifically the <code>toString</code>
    method will fail and there will likely be other unintended consequences.
  </div>
</div>

<h4 class="is-size-5" id="step-4">Step #4 - Add getter method for new property</h4>
<p class="content">
  Though we may want to have the data be only available to enum implementation chances are we'll want to expose it through
  some method. In our case we'll implement a simple <code>getAbbreviation</code> method that returns our abbreviation.
</p>

<pre class="content"><code class="language-php">&lt;php

namespace YourNamespace\Enums;

use Cspray\Yape\Enum;
use Cspray\Yape\EnumTrait;

final class Compass implements Enum {

    use EnumTrait;

    private $abbreviation;

    private function __construct(string $name, string $abbreviation) {
        $this->setName($name);
        $this->abbreviation = $abbreviation;
    }

    public function getAbbreviation() : string {
        return $this->abbreviation;
    }

    // ... rest of the class

}</code></pre>

<h4 class="is-size-5" id="step-5">Step #5 - Add new data to static method constructors</h4>
<p class="content">
  Each static method's call to <code>self::getSingleton()</code> will need to be adjusted to include the new dependency
  that we added to the constructor. Whatever arguments are passed to this method will be used as the arguments for the
  call to the constructor.
</p>

<pre class="content"><code class="language-php">&lt;php

namespace YourNamespace\Enums;

use Cspray\Yape\Enum;
use Cspray\Yape\EnumTrait;

final class Compass implements Enum {

    use EnumTrait;

    private $abbreviation;

    private function __construct(string $name, string $abbreviation) {
        $this->setName($name);
        $this->abbreviation = $abbreviation;
    }

    public function getAbbreviation() : string {
        return $this->abbreviation;
    }

    public static function North() : self {
        return self::getSingleton('North', 'N');
    }

    // ... rest of the class

}</code></pre>

<p class="content">
  Now our Enum has multiple data points associated to it and we can now call a new method on our Compass instances to
  retrieve this data point. An Enum can have as many constructor dependencies as is required for your use case.
</p>